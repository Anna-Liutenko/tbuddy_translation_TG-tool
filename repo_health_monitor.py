#!/usr/bin/env python3
"""
Repository Health Monitor

This script provides comprehensive repository health monitoring,
including daily health checks and continuous monitoring capabilities.
"""

import os
import sys
import json
import logging
import subprocess
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from pathlib import Path

from git_analyzer import GitStatusAnalyzer
from status_reporter import StatusReporter
from git_lfs_manager import GitLFSManager


class RepositoryHealthMonitor:
    """Monitors repository health and generates reports."""
    
    def __init__(self, repo_path: str = ".", github_token: Optional[str] = None):
        """
        Initialize Repository Health Monitor.
        
        Args:
            repo_path: Path to the git repository
            github_token: GitHub API token for enhanced monitoring
        """
        self.repo_path = os.path.abspath(repo_path)
        self.git_analyzer = GitStatusAnalyzer(repo_path)
        self.status_reporter = StatusReporter(repo_path, github_token)
        self.lfs_manager = GitLFSManager(repo_path)
        self.logger = logging.getLogger(__name__)
        
        # Health monitoring configuration
        self.health_config = {
            'max_file_size_mb': 50,
            'max_uncommitted_files': 20,
            'max_untracked_files': 10,
            'warn_behind_commits': 5,
            'warn_ahead_commits': 10,
            'health_report_retention_days': 30
        }
    
    def run_health_check(self, detailed: bool = False) -> Dict[str, Any]:
        """
        Run comprehensive repository health check.
        
        Args:
            detailed: Whether to include detailed file information
            
        Returns:
            Dictionary containing health check results
        """
        health_report = {
            'timestamp': datetime.now().isoformat(),
            'repository_path': self.repo_path,
            'overall_health': 'unknown',
            'health_score': 0,
            'checks': {},
            'issues': [],
            'recommendations': [],
            'summary': {}
        }
        
        try:
            self.logger.info("Starting repository health check...")
            
            # 1. Git repository status check
            self._check_git_status(health_report)
            
            # 2. File size and content checks
            self._check_file_health(health_report)
            
            # 3. Security and compliance checks
            self._check_security_compliance(health_report)
            
            # 4. Git LFS status check
            self._check_lfs_status(health_report)
            
            # 5. Remote synchronization check
            self._check_remote_sync(health_report)
            
            # 6. Calculate overall health score
            self._calculate_health_score(health_report)
            
            # 7. Generate recommendations
            self._generate_health_recommendations(health_report)
            
            # 8. Create summary
            self._create_health_summary(health_report, detailed)
            
        except Exception as e:
            self.logger.error(f"Error during health check: {e}")
            health_report['issues'].append({
                'type': 'health_check_error',
                'severity': 'critical',
                'message': f'Health check failed: {e}'
            })
            health_report['overall_health'] = 'critical'
        
        return health_report
    
    def _check_git_status(self, health_report: Dict[str, Any]):
        """Check git repository status."""
        try:
            # Check if it's a git repository
            if not self.git_analyzer.check_is_git_repository():
                health_report['checks']['git_repository'] = {
                    'status': 'failed',
                    'message': 'Not a git repository'
                }
                health_report['issues'].append({
                    'type': 'not_git_repo',
                    'severity': 'critical',
                    'message': 'Directory is not a git repository'
                })
                return\n            \n            health_report['checks']['git_repository'] = {\n                'status': 'passed',\n                'message': 'Valid git repository'\n            }\n            \n            # Get repository status\n            status_result = self.status_reporter.generate_comprehensive_report()\n            \n            if status_result.success and status_result.repository_status:\n                repo_status = status_result.repository_status\n                \n                # Check uncommitted changes\n                if repo_status.uncommitted_changes > self.health_config['max_uncommitted_files']:\n                    health_report['issues'].append({\n                        'type': 'too_many_uncommitted',\n                        'severity': 'medium',\n                        'message': f'Too many uncommitted files: {repo_status.uncommitted_changes}'\n                    })\n                \n                # Check untracked files\n                if len(repo_status.untracked_files) > self.health_config['max_untracked_files']:\n                    health_report['issues'].append({\n                        'type': 'too_many_untracked',\n                        'severity': 'low',\n                        'message': f'Too many untracked files: {len(repo_status.untracked_files)}'\n                    })\n                \n                health_report['checks']['git_status'] = {\n                    'status': 'passed',\n                    'uncommitted_changes': repo_status.uncommitted_changes,\n                    'untracked_files': len(repo_status.untracked_files),\n                    'is_synchronized': repo_status.is_synchronized\n                }\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking git status: {e}\")\n            health_report['checks']['git_status'] = {\n                'status': 'error',\n                'message': str(e)\n            }\n    \n    def _check_file_health(self, health_report: Dict[str, Any]):\n        \"\"\"Check file size and content health.\"\"\"\n        try:\n            # Check for large files\n            large_files = self.git_analyzer.check_large_files(self.health_config['max_file_size_mb'])\n            \n            health_report['checks']['large_files'] = {\n                'status': 'passed' if not large_files else 'warning',\n                'count': len(large_files),\n                'total_size_mb': sum(size for _, size in large_files)\n            }\n            \n            if large_files:\n                health_report['issues'].append({\n                    'type': 'large_files_detected',\n                    'severity': 'medium',\n                    'message': f'Found {len(large_files)} large files (>{self.health_config[\"max_file_size_mb\"]}MB)',\n                    'files': large_files[:5]  # Show first 5\n                })\n            \n            # Check for problematic files\n            problematic_files = self.git_analyzer.check_problematic_files()\n            total_problematic = sum(len(files) for files in problematic_files.values())\n            \n            health_report['checks']['problematic_files'] = {\n                'status': 'passed' if total_problematic == 0 else 'warning',\n                'count': total_problematic,\n                'categories': {k: len(v) for k, v in problematic_files.items() if v}\n            }\n            \n            if total_problematic > 0:\n                health_report['issues'].append({\n                    'type': 'problematic_files_detected',\n                    'severity': 'medium',\n                    'message': f'Found {total_problematic} problematic files that should not be committed',\n                    'categories': problematic_files\n                })\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking file health: {e}\")\n            health_report['checks']['file_health'] = {\n                'status': 'error',\n                'message': str(e)\n            }\n    \n    def _check_security_compliance(self, health_report: Dict[str, Any]):\n        \"\"\"Check security and compliance status.\"\"\"\n        try:\n            # Check if .gitignore exists\n            gitignore_path = os.path.join(self.repo_path, '.gitignore')\n            gitignore_exists = os.path.exists(gitignore_path)\n            \n            health_report['checks']['gitignore'] = {\n                'status': 'passed' if gitignore_exists else 'warning',\n                'exists': gitignore_exists\n            }\n            \n            if not gitignore_exists:\n                health_report['issues'].append({\n                    'type': 'missing_gitignore',\n                    'severity': 'medium',\n                    'message': '.gitignore file is missing'\n                })\n            \n            # Check for environment files\n            env_files = []\n            for root, dirs, files in os.walk(self.repo_path):\n                if '.git' in dirs:\n                    dirs.remove('.git')\n                \n                for file in files:\n                    if file.startswith('.env') or file.endswith('.key') or file.endswith('.pem'):\n                        env_files.append(os.path.relpath(os.path.join(root, file), self.repo_path))\n            \n            health_report['checks']['environment_files'] = {\n                'status': 'passed' if not env_files else 'critical',\n                'count': len(env_files)\n            }\n            \n            if env_files:\n                health_report['issues'].append({\n                    'type': 'environment_files_detected',\n                    'severity': 'critical',\n                    'message': f'Found {len(env_files)} environment/key files that should not be committed',\n                    'files': env_files\n                })\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking security compliance: {e}\")\n            health_report['checks']['security_compliance'] = {\n                'status': 'error',\n                'message': str(e)\n            }\n    \n    def _check_lfs_status(self, health_report: Dict[str, Any]):\n        \"\"\"Check Git LFS status.\"\"\"\n        try:\n            lfs_status = self.lfs_manager.get_lfs_status()\n            \n            health_report['checks']['git_lfs'] = {\n                'status': 'passed',\n                'available': lfs_status['lfs_available'],\n                'initialized': lfs_status['lfs_initialized'],\n                'tracked_patterns': len(lfs_status['tracked_patterns']),\n                'tracked_files': len(lfs_status['tracked_files'])\n            }\n            \n            # Check if LFS is needed but not set up\n            large_files = self.git_analyzer.check_large_files(100)  # Check for very large files\n            if large_files and not lfs_status['lfs_initialized']:\n                health_report['issues'].append({\n                    'type': 'lfs_recommended',\n                    'severity': 'low',\n                    'message': f'Git LFS recommended for {len(large_files)} large files'\n                })\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking LFS status: {e}\")\n            health_report['checks']['git_lfs'] = {\n                'status': 'error',\n                'message': str(e)\n            }\n    \n    def _check_remote_sync(self, health_report: Dict[str, Any]):\n        \"\"\"Check remote synchronization status.\"\"\"\n        try:\n            # Check remote connection\n            has_remote = self.git_analyzer.check_remote_connection()\n            \n            if not has_remote:\n                health_report['checks']['remote_sync'] = {\n                    'status': 'warning',\n                    'message': 'No remote connection available'\n                }\n                health_report['issues'].append({\n                    'type': 'no_remote_connection',\n                    'severity': 'medium',\n                    'message': 'Cannot connect to remote repository'\n                })\n                return\n            \n            # Check branch comparison\n            branch_comparison = self.git_analyzer.get_branch_comparison()\n            \n            ahead_count = branch_comparison.get('ahead', 0)\n            behind_count = branch_comparison.get('behind', 0)\n            \n            sync_status = 'passed'\n            if behind_count > self.health_config['warn_behind_commits']:\n                sync_status = 'warning'\n                health_report['issues'].append({\n                    'type': 'behind_remote',\n                    'severity': 'medium',\n                    'message': f'Local branch is {behind_count} commits behind remote'\n                })\n            \n            if ahead_count > self.health_config['warn_ahead_commits']:\n                sync_status = 'warning' if sync_status == 'passed' else 'critical'\n                health_report['issues'].append({\n                    'type': 'ahead_remote',\n                    'severity': 'low',\n                    'message': f'Local branch is {ahead_count} commits ahead of remote'\n                })\n            \n            health_report['checks']['remote_sync'] = {\n                'status': sync_status,\n                'ahead_count': ahead_count,\n                'behind_count': behind_count,\n                'is_synchronized': ahead_count == 0 and behind_count == 0\n            }\n            \n        except Exception as e:\n            self.logger.error(f\"Error checking remote sync: {e}\")\n            health_report['checks']['remote_sync'] = {\n                'status': 'error',\n                'message': str(e)\n            }\n    \n    def _calculate_health_score(self, health_report: Dict[str, Any]):\n        \"\"\"Calculate overall health score (0-100).\"\"\"\n        score = 100\n        \n        # Deduct points based on issues\n        for issue in health_report['issues']:\n            severity = issue.get('severity', 'medium')\n            if severity == 'critical':\n                score -= 25\n            elif severity == 'high':\n                score -= 15\n            elif severity == 'medium':\n                score -= 10\n            elif severity == 'low':\n                score -= 5\n        \n        # Deduct points for failed checks\n        for check_name, check_data in health_report['checks'].items():\n            if check_data.get('status') == 'error':\n                score -= 20\n            elif check_data.get('status') == 'warning':\n                score -= 10\n        \n        # Ensure score is not negative\n        score = max(0, score)\n        \n        health_report['health_score'] = score\n        \n        # Determine overall health\n        if score >= 90:\n            health_report['overall_health'] = 'excellent'\n        elif score >= 75:\n            health_report['overall_health'] = 'good'\n        elif score >= 50:\n            health_report['overall_health'] = 'fair'\n        elif score >= 25:\n            health_report['overall_health'] = 'poor'\n        else:\n            health_report['overall_health'] = 'critical'\n    \n    def _generate_health_recommendations(self, health_report: Dict[str, Any]):\n        \"\"\"Generate actionable health recommendations.\"\"\"\n        recommendations = []\n        \n        # Sort issues by severity for prioritized recommendations\n        critical_issues = [i for i in health_report['issues'] if i.get('severity') == 'critical']\n        high_issues = [i for i in health_report['issues'] if i.get('severity') == 'high']\n        medium_issues = [i for i in health_report['issues'] if i.get('severity') == 'medium']\n        \n        if critical_issues:\n            recommendations.append(\"🔴 CRITICAL: Address critical security issues immediately\")\n            for issue in critical_issues:\n                if issue['type'] == 'environment_files_detected':\n                    recommendations.append(\"   • Remove environment/key files and add to .gitignore\")\n                elif issue['type'] == 'not_git_repo':\n                    recommendations.append(\"   • Initialize git repository with 'git init'\")\n        \n        if high_issues:\n            recommendations.append(\"🟡 HIGH PRIORITY: Fix high-priority issues\")\n            for issue in high_issues:\n                if issue['type'] == 'behind_remote':\n                    recommendations.append(\"   • Pull remote changes with 'git pull'\")\n        \n        if medium_issues:\n            recommendations.append(\"🔵 MEDIUM PRIORITY: Address medium-priority issues\")\n            for issue in medium_issues:\n                if issue['type'] == 'large_files_detected':\n                    recommendations.append(\"   • Set up Git LFS for large files or add to .gitignore\")\n                elif issue['type'] == 'problematic_files_detected':\n                    recommendations.append(\"   • Update .gitignore to exclude problematic files\")\n                elif issue['type'] == 'missing_gitignore':\n                    recommendations.append(\"   • Create .gitignore file\")\n        \n        # General recommendations\n        if health_report['health_score'] < 75:\n            recommendations.append(\"💡 GENERAL: Run 'python git_push_resolver.py' for automated fixes\")\n        \n        if not recommendations:\n            recommendations.append(\"✅ Repository health is good - no immediate actions needed\")\n        \n        health_report['recommendations'] = recommendations\n    \n    def _create_health_summary(self, health_report: Dict[str, Any], detailed: bool = False):\n        \"\"\"Create health check summary.\"\"\"\n        summary = {\n            'timestamp': health_report['timestamp'],\n            'overall_health': health_report['overall_health'],\n            'health_score': health_report['health_score'],\n            'total_issues': len(health_report['issues']),\n            'critical_issues': len([i for i in health_report['issues'] if i.get('severity') == 'critical']),\n            'checks_passed': len([c for c in health_report['checks'].values() if c.get('status') == 'passed']),\n            'checks_total': len(health_report['checks'])\n        }\n        \n        if detailed:\n            summary['issue_breakdown'] = {}\n            for issue in health_report['issues']:\n                severity = issue.get('severity', 'unknown')\n                if severity not in summary['issue_breakdown']:\n                    summary['issue_breakdown'][severity] = 0\n                summary['issue_breakdown'][severity] += 1\n        \n        health_report['summary'] = summary\n    \n    def save_health_report(self, health_report: Dict[str, Any], output_dir: str = \"health_reports\") -> str:\n        \"\"\"Save health report to file.\"\"\"\n        try:\n            # Create output directory\n            output_path = os.path.join(self.repo_path, output_dir)\n            os.makedirs(output_path, exist_ok=True)\n            \n            # Generate filename with timestamp\n            timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n            filename = f\"health_report_{timestamp}.json\"\n            filepath = os.path.join(output_path, filename)\n            \n            # Save report\n            with open(filepath, 'w') as f:\n                json.dump(health_report, f, indent=2, default=str)\n            \n            self.logger.info(f\"Health report saved to: {filepath}\")\n            return filepath\n            \n        except Exception as e:\n            self.logger.error(f\"Error saving health report: {e}\")\n            return \"\"\n    \n    def cleanup_old_reports(self, report_dir: str = \"health_reports\", retention_days: int = None):\n        \"\"\"Clean up old health reports.\"\"\"\n        if retention_days is None:\n            retention_days = self.health_config['health_report_retention_days']\n        \n        try:\n            report_path = os.path.join(self.repo_path, report_dir)\n            if not os.path.exists(report_path):\n                return\n            \n            cutoff_date = datetime.now() - timedelta(days=retention_days)\n            \n            for filename in os.listdir(report_path):\n                if filename.startswith('health_report_') and filename.endswith('.json'):\n                    filepath = os.path.join(report_path, filename)\n                    file_mtime = datetime.fromtimestamp(os.path.getmtime(filepath))\n                    \n                    if file_mtime < cutoff_date:\n                        os.remove(filepath)\n                        self.logger.info(f\"Removed old health report: {filename}\")\n                        \n        except Exception as e:\n            self.logger.error(f\"Error cleaning up old reports: {e}\")\n    \n    def format_health_report(self, health_report: Dict[str, Any]) -> str:\n        \"\"\"Format health report for console output.\"\"\"\n        lines = []\n        \n        # Header\n        health_icon = {\n            'excellent': '🟢',\n            'good': '🟡',\n            'fair': '🟠',\n            'poor': '🔴',\n            'critical': '💥'\n        }.get(health_report['overall_health'], '❓')\n        \n        lines.append(f\"\\n{health_icon} REPOSITORY HEALTH REPORT\")\n        lines.append(\"=\" * 50)\n        lines.append(f\"📁 Repository: {os.path.basename(self.repo_path)}\")\n        lines.append(f\"⏰ Timestamp: {health_report['timestamp']}\")\n        lines.append(f\"📊 Health Score: {health_report['health_score']}/100 ({health_report['overall_health'].upper()})\")\n        lines.append(\"\")\n        \n        # Summary\n        summary = health_report.get('summary', {})\n        lines.append(\"📋 SUMMARY\")\n        lines.append(\"-\" * 20)\n        lines.append(f\"Total Issues: {summary.get('total_issues', 0)}\")\n        lines.append(f\"Critical Issues: {summary.get('critical_issues', 0)}\")\n        lines.append(f\"Checks Passed: {summary.get('checks_passed', 0)}/{summary.get('checks_total', 0)}\")\n        lines.append(\"\")\n        \n        # Issues\n        if health_report['issues']:\n            lines.append(\"⚠️  ISSUES FOUND\")\n            lines.append(\"-\" * 20)\n            \n            for issue in health_report['issues']:\n                severity_icon = {\n                    'critical': '🔴',\n                    'high': '🟡',\n                    'medium': '🔵',\n                    'low': '🟢'\n                }.get(issue.get('severity'), '❓')\n                \n                lines.append(f\"{severity_icon} {issue.get('message', 'Unknown issue')}\")\n            \n            lines.append(\"\")\n        \n        # Recommendations\n        if health_report['recommendations']:\n            lines.append(\"💡 RECOMMENDATIONS\")\n            lines.append(\"-\" * 20)\n            \n            for rec in health_report['recommendations']:\n                lines.append(rec)\n            \n            lines.append(\"\")\n        \n        # Checks detail\n        lines.append(\"🔍 CHECK DETAILS\")\n        lines.append(\"-\" * 20)\n        \n        for check_name, check_data in health_report['checks'].items():\n            status_icon = {\n                'passed': '✅',\n                'warning': '⚠️ ',\n                'error': '❌',\n                'failed': '❌'\n            }.get(check_data.get('status'), '❓')\n            \n            lines.append(f\"{status_icon} {check_name.replace('_', ' ').title()}: {check_data.get('status', 'unknown')}\")\n        \n        return \"\\n\".join(lines)\n\n\ndef main():\n    \"\"\"CLI interface for Repository Health Monitor.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(\n        description=\"Repository Health Monitor\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExamples:\n  python repo_health_monitor.py check                    # Basic health check\n  python repo_health_monitor.py check --detailed        # Detailed health check\n  python repo_health_monitor.py check --save            # Save report to file\n  python repo_health_monitor.py daily                   # Daily health check\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        'action',\n        choices=['check', 'daily', 'cleanup'],\n        help='Action to perform'\n    )\n    \n    parser.add_argument(\n        '--path', '-p',\n        default='.',\n        help='Path to git repository (default: current directory)'\n    )\n    \n    parser.add_argument(\n        '--detailed',\n        action='store_true',\n        help='Include detailed information in report'\n    )\n    \n    parser.add_argument(\n        '--save',\n        action='store_true',\n        help='Save report to file'\n    )\n    \n    parser.add_argument(\n        '--format',\n        choices=['text', 'json'],\n        default='text',\n        help='Output format (default: text)'\n    )\n    \n    parser.add_argument(\n        '--github-token',\n        help='GitHub API token for enhanced monitoring'\n    )\n    \n    parser.add_argument(\n        '--verbose', '-v',\n        action='store_true',\n        help='Enable verbose logging'\n    )\n    \n    args = parser.parse_args()\n    \n    # Setup logging\n    level = logging.DEBUG if args.verbose else logging.INFO\n    logging.basicConfig(\n        level=level,\n        format='%(asctime)s - %(levelname)s - %(message)s'\n    )\n    \n    try:\n        # Initialize monitor\n        github_token = args.github_token or os.getenv('GITHUB_TOKEN')\n        monitor = RepositoryHealthMonitor(args.path, github_token)\n        \n        if args.action == 'check':\n            # Run health check\n            health_report = monitor.run_health_check(args.detailed)\n            \n            # Save report if requested\n            if args.save:\n                filepath = monitor.save_health_report(health_report)\n                if filepath:\n                    print(f\"💾 Report saved to: {filepath}\")\n            \n            # Output report\n            if args.format == 'json':\n                print(json.dumps(health_report, indent=2, default=str))\n            else:\n                print(monitor.format_health_report(health_report))\n            \n            # Exit with appropriate code based on health\n            if health_report['overall_health'] in ['critical', 'poor']:\n                sys.exit(1)\n            else:\n                sys.exit(0)\n        \n        elif args.action == 'daily':\n            # Daily health check with automatic save\n            print(\"🗓️  Running daily health check...\")\n            \n            health_report = monitor.run_health_check(detailed=True)\n            filepath = monitor.save_health_report(health_report)\n            \n            # Cleanup old reports\n            monitor.cleanup_old_reports()\n            \n            # Show summary\n            print(monitor.format_health_report(health_report))\n            \n            if filepath:\n                print(f\"\\n💾 Daily report saved to: {filepath}\")\n        \n        elif args.action == 'cleanup':\n            # Cleanup old reports\n            print(\"🧹 Cleaning up old health reports...\")\n            monitor.cleanup_old_reports()\n            print(\"✅ Cleanup completed\")\n    \n    except KeyboardInterrupt:\n        print(\"\\n⚠️  Operation cancelled by user\")\n        sys.exit(130)\n    except Exception as e:\n        print(f\"❌ Unexpected error: {e}\")\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()